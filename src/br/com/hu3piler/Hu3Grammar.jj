/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */options{  static = true;
  DEBUG_PARSER = false;
  DEBUG_TOKEN_MANAGER = false;}PARSER_BEGIN(Hu3Grammar)package br.com.hu3piler;

public class Hu3Grammar{  public static void main(String args []) throws ParseException  {    Hu3Grammar parser = new Hu3Grammar(System.in);    while (true)    {      System.out.println("Reading from standard input...");      System.out.print("Enter an expression like \"1+(2+3)*4;\" :");      try      {        switch (Hu3Grammar.one_line())        {          case 0 :           System.out.println("OK.");          break;          case 1 :           System.out.println("Goodbye.");          break;          default :           break;        }      }      catch (Exception e)      {        System.out.println("NOK.");        System.out.println(e.getMessage());        Hu3Grammar.ReInit(System.in);      }      catch (Error e)      {        System.out.println("Oops.");        System.out.println(e.getMessage());        break;      }    }  }}/*
 * The syncroKind argument represents the kind for the compilers' resync,
 * returning the last token before the last sync.
 */

static public void sintaticError(String expected, int synchroKind) {
        Token t = getToken(1);
        System.out.print("\n++ Sintatic error (line "+t.beginLine);
        System.out.println(", column "+t.beginColumn+") ++");
        System.out.print("Found \'"+t.image+"\'. ");
        System.out.println("Expected: " + expected);
        if (t.kind != synchroKind) {
            // Kind 0 represents <EOF>
            while(t.kind!=kindSincronizacao && t.kind != 0) {
                t = getNextToken();
            }
        }
}

static public void semanticError(String s) {

}

static public void lexicError(String s) {

}

static public void warning(String s) {

}
    PARSER_END(Hu3Grammar)SKIP : {  " "| "\r"| "\t"| "\n"}
SKIP : { "/*" : multiLineComment }

<multiLineComment>

SKIP: { "*/" : DEFAULT | <~[]> }

SKIP : { "//" : lineComment }

<lineComment>

SKIP: { "\n" : DEFAULT | <~[]> }

TOKEN : {
        < NUMBER : (["0" - "9"])*(".")?(["0" - "9"])+ > 
    |   < STRING : ("\"")(~["\""])*("\"") >
    |   < VAR : ("_")(["a"-"z"]|["A"-"Z"])(["a"-"z"]|["A"-"Z"]|["0"-"9"])* >
    |   < ATRIB : "=" >
    |   < PARL : "(" >
    |   < PARR : ")" >
    |   < DOTCOMMA : ";" >
    |   < COMMA : "," >
}

// Function operators
TOKEN : {
	   	< IF : "se" >
    |   < ELSIF : "senaoSe" >
    |   < ELSE : "senao" >
    |   < ENDIF : "fimSe" >
    |   < CHOOSE : "escolha" >
    |   < CASE : "caso" >
    |   < OTHERS : "outros" >
    |   < ENDCHOOSE : "fimEscolha" >
    |   < WHILE : "enquanto" >
    |   < ENDWHILE : "fimEnquanto" >
    |   < FOR : "para" >
    |   < UNTIL : "ate" >
    |   < MOVE : "passo" >
    |   < ENDFOR : "fimPara" >
}

// Variable types
TOKEN : {
  	   < TYPENUM : "numero" >
    |   < TYPESTRING : "string" >}
// Arithmetic operators
TOKEN : {
     	< POW : "^" >
    |   < MUL : "*" >
    |   < DIV : "/" >
    |   < ADD : "+" >
    |   < SUB : "-" >}// Logic operators
TOKEN : {
  	   < AND : "e" >
    |   < OR : "ou" >
    |   < NOT : "nao" >
    |   < SPECIALOR : "OU" >}

// Comparation tokens
TOKEN : {
     	< BIGGER : ">" >
    |   < LESS : "<" >
    |   < BIGEQUAL : ">=" >
    |   < LESSEQUAL : "<=" >
    |   < DIFFERENT : "!=" >
    |   < COMPARE : "==" >}

// Language built-in functions
TOKEN : {
  	   < SHOW : "exibe" >
    |   < READ : "leia" >}
void start(): { CommandList cl;}
{
  cl = readCommandList() <EOF>
  {return cl;}}
CommandList readCommandList(): {CommandList cl = new CommandList();}
{
  (readCommand(cl))*  {
    return cl;
  } 
}

void readCommand(CommandList cl): {CommandList auxList; Command command}
{
  		atribution()
    |   declaration()
    |   read()
    |   show()
    |   ifCommand()
    |   switchCommand()
    |   whileCommand()
    |   forCommand()
}

Expression semanticAnalizer(): {Expression expression = new Expression(); Item item = null; Token token = null; }
{
	/*
	 * First of all we need to evaluate the all the tokens regarding their precedence.
	 * So as you can see each function will call the function that deals with the token 
	 * with the most precedence so the last one listed below is actually the first one evaluated.
	 */
	checkAnd(expression)
	(	  token = < OR >
	  checkAnd(expression)
	  {
		item = new Item(Type.OPERATOR, token.image)
		expression.addItem(item);
	  }
	| token = < SPECIALOR >
	 checkAnd(expression)
	 {
		item = new Item(Type.OPERATOR, token.image)
		expression.addItem(item);
	  }
	)* // Which means our token can appear none or more times


	/*
	 * Since all the functions will be called recursively, from this point onwards,
	 * the semantic analysis will be performed.
	 */


	
}

void checkAnd(Expression expression): {Token token = null; Item item = null;}
{
	checkComparation(expression)
	(
        token = < AND >
        checkComparation(expression)
        {
            item = new Item(Type.OPERATOR, token.image);
            expression.addItem(item);
        }
    )*	
}

void checkComparation(Expression expression): {Token token = null; Item item = null;}
{
  checkArithmetic(expression)
  (
    token = < BIGGER >
    { expression.setDataType(Type.NUMBER)}
    checkArithmetic(expression)
    {
		item = new Item(Type.OPERATOR, token.image);
        expression.addItem(item);
    }
  | token = < LESS >
    { expression.setDataType(Type.NUMBER)}
    checkArithmetic(expression)
    {
		item = new Item(Type.OPERATOR, token.image);
        expression.addItem(item);
    }
  | token = < BIGEQUAL >
  	{ expression.setDataType(Type.NUMBER)}
    checkArithmetic(expression)
    {
		item = new Item(Type.OPERATOR, token.image);
        expression.addItem(item);
    }
  | token = < LESSEQUAL >
  	{ expression.setDataType(Type.NUMBER)}
    checkArithmetic(expression)
    {
		item = new Item(Type.OPERATOR, token.image);
        expression.addItem(item);
    }
 | token = < DIFFERENT >
 	{ expression.setDataType(Type.NUMBER)}
    checkArithmetic(expression)
	{
		item = new Item(Type.OPERATOR, token.image);
        expression.addItem(item);
    }
 | token = < COMPARE >
 	{ expression.setDataType(Type.NUMBER)}
    checkArithmetic(expression)
    {
		item = new Item(Type.OPERATOR, token.image);
        expression.addItem(item);
    }  
    )*
}

void checkArithmetic(Expression expression): {Token token = null; Item item = null;}
{
  checkMulOrDiv(expression)
  (
    token = < ADD >
	checkMulOrDiv(expression)
	{
		item = new Item(Type.OPERATOR, token.image);
        expression.addItem(item);
	}
	|token = < SUB >
	checkMulOrDiv(expression)
	{
		item = new Item(Type.OPERATOR, token.image);
        expression.addItem(item);
	}        )*
}

void checkMulOrDiv(Expression expression): {Token token = null; Item item = null;}
{
  checkPow(expression)
  (
    token = < MUL >
    checkPow(expression)
    {
		item = new Item(Type.OPERATOR, token.image);
        expression.addItem(item);
    }
  | token = < DIV >
  	checkPow(expression)
  	{
		item = new Item(Type.OPERATOR, token.image);
        expression.addItem(item);
  	}   )*
}

void checkPow(Expression expression): {Token token = null; Item item = null;}
{
  checkNot(expression)
  (
    token = < POW >
    checkNot(expression)
    {
		item = new Item(Type.OPERATOR, token.image);
        expression.addItem(item);
    }
  )?  
}

void checkNot(Expression expression): {Token token = null; Item item = null;}
{
  (
    token = < NOT >
    {
      item = new Item(Type.OPERATOR, token.image);
      expression.addItem(item);
    }  )*
}